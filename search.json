[{"title":"Mysql事务","url":"/2025/05/05/A1-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E4%BA%8B%E5%8A%A1/","content":"事务四大特性原子性：保障：undo log\n定义：一系列操作要么全执行，要么全不执行；\n原理：通过undo log实现，undo log属于逻辑日志，保证事务原子性，记录 sql执行相关的信息，当发生回滚时，会根据undo log内容做与之前相反的工作。例如：对于每个insert，回滚时会执行delete；对于每个update，回滚时会执行一个相反的update，把数据改回去。\n\n\n持久性保障：redo log\n定义：保证事务提交后不会因为宕机等原因造成数据的丢失； \n背景InnoDB存储引擎的数据存放在磁盘中，如果每次读写数据都需要磁盘IO，效率会很低。因此，InnoDB提供了缓存Buffer Pool，Buffer Pool作为访问磁盘的缓冲区。当从数据库读取数据时，首先从Buffer Pool中读取，如果Buffer Pool中没有，再从磁盘读取后放入Buffer Pool；写入数据时，首先写入Buffer Pool，Buffer Pool中修改的数据会 定期刷新到磁盘（刷脏）。\nBuffer Pool虽然提高了读写数据的效率，但也存在问题：如果Mysql宕机，此时Buffer Pool中修改的数据还没刷新到磁盘，就会导致数据丢失，事务的持久性也就无法保证。\n解决方式数据修改时，先在redo log中记录这次操作，然后修改 Buffer Pool中的数据。当事务提交时，会调用 fsync接口对redo log进行刷盘。如果Mysql宕机，重启时会读取redo log数据进行恢复。redo log是预写日志，所有修改先写入日志，再更新到Buffer Pool，保证数据不会因Mysql宕机而丢失。\nredo log在事务提交时写入磁盘，但比刷脏快，具体原因\n刷脏是随机IO（寻道+旋转+寻址），每次修改的数据位置随机，但写 redo log是追加操作，属于顺序IO；\n刷脏是以数据页（默认16k）为单位，一个数据页Page上一个小修改都要整页写入；而 redo log中只包含真正需要写入的部分，无效IO 减少。\n\n隔离性保障：加锁\n定义：保证事务间的执行互不影响\n两方面考虑：读、写\n加锁： 一个事务写操作，对另一个事务写操作；\nMVCC： 一个事务写操作，对另一个事务读操作；\n一致性保障：数据库层面 + 应用层面\n定义：对于同一份数据的不同操作，要保证一致性；\nredo log与binlog区别1.作用不同redo log保证Mysql宕机也不会影响持久性，保证事务持久性。\nbinlog 保证服务器可以基于时间点恢复数据，binlog还用于主从复制；\nundo log 保证事务原子性、隔离性；\n2.层次不同redo log是 InnoDB存储引擎实现的；\nbinlog 是Mysql 服务器层实现的，同时支持InnoDB和其他存储引擎；\n3.内容不同redo log是物理日志，内容基于磁盘的Page；\nbinlog 是二进制，根据binlog_format参数的不同，可能基于 sql语句，基于数据本身或者二者的混合；\n锁类型行锁1.共享锁（S Lock）可以和其他锁共存，多个事务可以同时访问同一份数据，但只能读，不能修改；\n2.排他锁（X Lock）排他锁和其他锁不能共存，一个事务获取一个数据行的排他锁，其他事务不能再获取该行的 共享锁和排他锁，获取排他锁的事务可以对数据进行读取和修改；\n总结：读时加共享锁，其他事务可以并发读，但不能写；写时加排它锁，其他事务不能并发写，也不能并发读。\n表锁对整个表都加锁，绝大部分情况都使用行锁，便于事务处理，但在个别特殊事务中，也考虑使用表锁，例如：当事务需要更新大部分或全部数据时，表比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下考虑使用表锁来提高该事务的执行速度。\n间隙锁（Gap锁）定义：使用范围条件检索数据，请求共享锁或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做 “间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这就是间隙锁（GAP锁）。\nSELECT c1 FROM t  WHERE c1 BETWEEN 10 and 20 FOR UPDATE;\n\n解释：意思是锁住 10~15间的数据，如果id&#x3D;10的数据已存在，别的用户不可以修改这条数据。但如果 id&#x3D;15的数据并不存在，也是不可以插入的，因为无论该列中是否已有这样的值，该范围中id在（10，15），现有值的间隙也是锁定的。\n间隙锁作用：防止幻读，不使用间隙锁，其他事务可以将数据插入到查询区间，本事务再次查询就会发生幻读；Record Lock： 锁定一个记录上的索引，而不是记录本身；\nGap Lock：锁定索引之间的间隙，但不包含索引本身；\nNext-Key Lock： Record Locks + Gap Locks 结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。\nMVCC多版本并发控制（Multi-Version Concurrency Control）定义：MVCC是InnoDB 存储引擎实现 已提交读、可重复读 隔离级别的一种具体方式；\n实现MVCC在 Undo log日志中存储快照信息，通过日志中的回滚指针把一个数据行（Record）的所有快照连接起来；\n\n\n版本号\n系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会自动递增；\n事务版本号：事务开始时的系统版本号；\n\n隐藏的列：MVCC 在每行记录后面都保存着 两个隐藏的列，用来存储两个版本号。\n\n创建版本号：指示创建一个数据行的快照时的系统版本号； \n删除版本号：如果该快照的删除版本号 &gt; 当前事务版本号，表示该快照有效，否则表示该快照已经被删除。\n\nMvcc总结A 事务读取数据，记录此时刻的快照 id 值， 放在 ReadView 中保存，每次对数据修改都会改变快照 id 值，此id 值保持递增，当后来再次读取 数据时，会比较此时的数据版本 id 值，是否 &gt; 之前的 id 值，如果 &gt; , 说明已经被修改；\n通 undo log 日志，查询之前记录数据的快照，访问那个版本时的数据。\nRR隔离级别1.已提交读（RC）隔离级别下的非加锁读RC与 RR一样，都使用了 MVCC，其主要区别在于：\nRR 是在事务开始后第一次执行select前创建ReadView，直到事务提交都不会再创建；RR可以避免脏读，不可重复读\nRC 每次执行select前都会重新建立一个新的ReadView，如果事务 A第一次select后，事务B对数据进行修改并提交，那么事务A第二次select 时会重新建立新的ReadView，此时事务 B的修改对事务 A是可见的；所以RC隔离级别可以避免脏读，但是无法避免不可重复读和幻读。\n2.加锁读 与 next-key lock按照是否加锁，Mysql 读可以分为两种： \n1.非加锁读（快照读，一致性读），使用普通 select语句，这种情况下使用 MVCC避免了脏读，不可重复读，幻读，保证了隔离性。\n2.加锁读，在查询时会对查询数据加锁（共享锁或排它锁）；由于锁的特性，当某事务对数据进行加锁读后，其他事务无法对数据进行写操作，因此可以 避免脏读和不可重复读。\n避免幻读需要通过 next-key lock，它是一种行锁，相当于 record lock(记录锁) + gap lock(间隙锁)；其不仅会锁住 记录本身(record lock功能)，还会 锁定一个范围(gap lock功能)；因此，加锁读同样可以避免脏读，不可重复读和幻读，保证隔离性。\n快照读&amp;当前读快照读 读取历史数据； MVCC 的 select 操作是快照中的数据，不需要进行加锁操作。 \n当前读读取数据库当前版本最新数据，MVCC 对数据库进行修改的操作（insert、update、delete）需要进行加锁操作，从而读取最新的数据。\n总结：MVCC使用加锁，但避免了 select 加锁 , Mysql为了减少锁处理的时间，提升并发能力，引入了快照读的概念，使得 select不用加锁。而 update，insert ，delete 这些 “当前读”的隔离性，需要通过加锁来实现。\n事务在执行普通select 操作时，在访问记录版本链的过程中，可以使用不同事务的读-写，写-读操作并发执行，从而提升系统性能。\n事务隔离级别\n\n未提交读定义：总是 读取最新的数据行，没有任何加锁，更新数据就会被读取到，直接返回记录的最新值，脏读、幻读、不可重复读都有可能发生。\n问题：事务可以读取 其他未提交事务的执行结果。\n已提交读RC定义：根据 MVCC实现，事务每次查询开始时，会生成一个独立的 ReadView，在数据库表中看到的一行记录可能有多个版本，每个版本记录除了有数据本身外，还有一个表示版本的字段（row trx_id），在事务开始时，向事务系统申请，按时间先后顺序递增。\n问题：事务可以读取 已经提交事务所做的改变。\n可重复读RR定义：在事务开始时生成一个当前事务全局性的快照，同一事务在 多次读取数据时，可以读取到相同的结果。\n可串行化定义：各个事务间串行执行，对所有读取的数据行都加共享锁，避免并行访问。通过MVCC + Next-Key Lock共同实现，这个级别可能 导致大量的超时现象和锁竞争。\n各隔离级别的问题脏读：不同事务下，当前事务可以读取到另外事务未提交的数据。\n不可重复读：同一事务内多次读取同一数据，读取到的数据可能不一样。\n幻读：一个事务读取某一范围的数据行时，另一个事务在该范围内插入新行，此事务再次读取范围内的数据行时，会返回之前不存在的数据行（新插入的数据行）。\nRC&#x2F;RR区别RC 在每一次进行 普通 select 操作前都会生成一个ReadView。\nRR 只在第一次进行普通 select 操作前生成一个ReadView，数据的可重复读就是 ReadView的重复使用。\n因为 B线程修改数据提交后，A线程第二次 select时，不再进行 id 值的比较，会重建ReadView，使得数据丢失。\n可重复读\nselect 操作不可重复读的问题，通过 MVCC 得到解决；\nupdate，delete不可重复读问题，通过 Record Lock 解决；\ninsert 不可重复读问题，通过 Next-Key Lock解决；\n\n根据 MVCC实现，只会根据事务中第一次查询时生成的 ReadView。\n已提交读\n当前事务内的更新，可以读到；\n版本 未提交，不能读到； \n版本 已提交，但是却在快照创建后提交的不能读到； \n版本 已提交，且在快照创建前提交的可以读到；\n\n已提交读&amp;可重复读区别：在快照的创建上，可重复读仅在事务开始时创建一次，已提交读每次执行语句时都重新创建一次。\n","categories":["Mysql","事务"],"tags":["Mysql"]},{"title":"Mysql索引","url":"/2025/05/04/A1-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%B4%A2%E5%BC%95/","content":"InnoDB索引\n支持 事务、外键、行锁\n聚簇索引，叶子节点data域存行记录\n\nInnoDB采用 MVCC方式支持高并发，实现四个标准隔离级别(未提交读、已提交读、可重复读-默认、可串行化)。\n\n\n\n\n\n\n\n\nMyIsam索引\n不支持 事务，外键，行锁；   \n非聚簇索引，叶子节点data域中存引用地址；\n\n\n\n索引优缺点索引优点\n提高数据查询效率，降低数据库 IO成本；\n被索引的列会自动排序，包括单列索引&amp;组合索引，按照索引列排序，order by语句效率更高；\n\n索引缺点\n索引会占磁盘空间；\n索引会降低更新表的效率，每次对表增删改，不仅要更新数据，还要更新对应的索引；\n\n索引结构Hash :  不适合范围查找；无法用于排序与分组；\n二叉树：根节点的取值，容易导致 二叉树不分叉，降低查询效率；\n平衡二叉树：不支持 范围查询，范围查询时需要从根节点多次遍历，效率低；\nB树：\nB树不支持范围查询，在非叶子节点中也保存数据记录；\n每个节点的 data域存储 行记录，行的大小随着列数的增多而变大，这时页中可存储的数据量会变少，树结构会变高，磁盘IO次数就会变多；\n\nB+树结构：\n支持范围查询，只在叶子节点data域中存数据；且主键具备唯一性，不需再向后查找，&lt;&#x3D;终止；\nIO读取一页（默认16K）数据，数据存储在磁盘中，查询数据时，需要先把 磁盘中的数据加载到内存，磁盘IO操作很耗时，所以优化重点就是 尽量减少磁盘 IO 操作。B+树在非叶子中仅保存索引（不保存数据），相比B树存储同样多的数据，树的高度会更低，从而减少磁盘IO；\n\n各种索引主键索引主键索引 &#x3D;&#x3D; 聚簇索引，当一个表没有创建主键索引时，InnoDB会自动构建聚簇索引。\n\n在表上定义 主键 PRIMARY KEY，InnoDB 将 主键索引用作聚簇索引；                                                     \n如果表没有定义主键，InnoDB会选择 第一个不为NULL的唯一索引列  用作聚簇索引；\n以上两个都没有，会使用一个 6 字节长整型字段构建聚簇索引，该 ROWID字段会在插入新行时自动递增；\n\n辅助索引聚簇索引之外的所有其他索引。\n索引查询过程：非主键索引（辅助索引）的其他索引查询，需要先根据辅助索引B+树找到叶子节点data域中存储的主键索引，再根据主键索引找到实际数据。\n\n\n前缀索引定义字符串的一部分作为索引，如果创建索引的语句不指定前缀长度，索引默认包含整个字符串。\n优点：定义好长度可以做到节省空间，又不用额外增加太多的查询成本。\n注意：有前缀索引的联合索引一定会回表，虽然联合索引已包含相关信息，但还是会回表，因为有前缀索引，不确定到底是不是一个完整的信息。例如： www.aobing@mogu.com 一个完整的邮箱去查询，但无法判断后续是否有数据，不知道是否是完整的数据，所以需要回表去判断。\n联合索引联合索引设计原则\n频繁使用的列、区分度高的列放在前面；\n范围查询的列放在复合索引的最后面，例如 idx_status_create_time；\n将常需要作为 查询返回的字段，增加到联合索引中，通过联合索引上增加字段来使用覆盖索引；\n\n联合索引优势1.减少开销： 建联合索引(col1,col2,col3)，实际相当于建 (col1),(col1,col2),(col1,col2,col3)三个索引,每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引可以有效的减少开销！\n2.覆盖索引：联合索引通过遍历索引取得数据，无需回表，减少io操作，提升性能；\n3.效率高： 索引列越多，通过索引筛选出的数据越少。\n例如：有1000W条数据的表，有如下sql：select from table where col1&#x3D;1 and col2&#x3D;2 and col3&#x3D;3, 假设每个条件可以筛选出10%数据，如果只有单值索引，那么通过该索引能筛选出1000W10%&#x3D;100w条数据，然后再回表从 100w条数据中找到符合col2&#x3D;2 and col3&#x3D; 3的数据，然后再排序，再分页；\n如果是联合索引，通过索引筛选出1000w10% 10% *10%&#x3D;1w，效率明显提升。\n联合索引查询过程\n覆盖索引由多个字段组合成的联合索引，如：idx_abc(a,b,c)索引，在查询时，如果只需要 abc字段，则查询到联合索引的叶子节点就可以直接返回，不需要回表。\n注：Mysql优化器会根据联合索引字段位置，调整where 后边的查询条件，让其满足索引顺序。\n示例：创建 idx_abc(a,b,c)索引，相当于创建 (a)、（a,b）（a,b,c）三个索引，节省空间。在执行sql时，优化器会调整where后a,b,c的顺序，让其用上索引。\nSELECT * FROM table WHERE a IN (1,2,3) and b &gt; 1; 还是对(a，b)建立索引，因为 IN可视为等值引用，不会中止索引匹配，所以还是(a,b)SELECT * FROM table WHERE a &gt; 1 and b = 2 and c &gt; 3; (b,a)或者(b,c)都可以，要结合具体情况具体分析。select * from t where a=1 and b=1 and c =1;  #这样可以利用到定义的索引（a,b,c）,用上a,b,c select * from t where a=1 and b=1;           #这样可以利用到定义的索引（a,b,c）,用上a,b select * from t where b=1 and a=1;     #这样可以利用到定义的索引（a,b,c）,用上a,b（mysql有查询优化器） select * from t where a=1;             #这样也可以利用到定义的索引（a,b,c）,用上a select * from t where b=1 and c=1;     #这样不可以利用到定义的索引（a,b,c）； 最左 a 不匹配select * from t where a=1 and c=1;     #这样可以利用到定义的索引（a,b,c），但只用上a索引，b,c索引用不到 \n\n\n\n最左匹配原则\n联合索引查询时，Mysql一直向右匹配，直至遇到范围查询 ( &gt;、&lt;、between、like ) 停止匹配。推荐使用联合索引替代多个单列索引使用。\n联合索引只有先确定前一个（左侧的值）后，才能确定下一个值。如果有范围查询，联合索引中使用范围查询的字段后的索引在该条 SQL 中都不会起作用。\n注意：in 和 &#x3D;  都可以乱序，比如有索引（a,b,c），语句 select * from t where c &#x3D;1 and a&#x3D;1 and b&#x3D;1，这样的语句也可以用到最左匹配，因为 MySQL优化器会分析 SQL 语句，将其优化成索引可以匹配的形式，即 select * from t where a &#x3D;1 and a&#x3D;1 and c&#x3D;1。\n\n索引设置建议\n尽量保持自增；\n差异性大的字段；\n出现频率高的字段，或常在where条件中出现的字段；\n小字段（减少所占用的空间）；\n\n破坏索引方式1.索引列 有函数运算\n2.索引列 有  !&#x3D;   &lt;&gt;    not in    not exist \n3.like 条件使索引生效，like后不能以%开头， like %字段名%、like %字段名 这类语句会使索引失效；\n4.字符型索引列；  \n5.隐式类型转换；\n示例：select * from t where id &#x3D; 1; 如果 id 是字符类型的，1是数字类型的，Mysql底层会对 比较进行转换，相当于加了 cast( id AS signed int ) 这样的函数，函数会导致走不上索引。 \n示例：FROM_UNIXTIME(create_time) &#x3D; ‘2016-06-06’ ，不会使用索引，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较；\n优化：create_time &#x3D; UNIX_TIMESTAMP(‘2016-06-06’)；\n","categories":["Mysql","索引"],"tags":["Mysql"]},{"title":"学习方法论","url":"/2025/05/02/%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AE%BA/","content":"深度 – 链式学习法从一个技术点出发，不断的输入挖掘，不断的下探一步，问问自己为什么？\n宽度 – 比较学习法类似技术选项的调研，当前市面上还有哪些其他类型的技术，横向对比。\n\n\n5W1H方法what：问题的类型及标准&amp;依据\nwho：问题的主题是谁\nwhich：问题的具体表现&amp;特定的状况（定向描述）\nwhere：问题的空间范围&amp;特定领域\nwhen：问题的时间范围\nhow：问题到了何种程度（怎样、多少…定量描述）\n个人写作模板1.问题是什么？（背景）\n2.当前现状？\n3.预期效果？\n4.面临的挑战？\n5.拆分问题？（分治–实现细节）\n6.横向方案对比？\n7.复盘总结（优点、缺点、后续改进）\n时间管理精力专注1.抵制手机诱惑，固定时间看手机\n2.番茄工作法\n3.工作时间高度专注\n固定深造1.工作日：早起1h、晚睡1h\n2.周末时间选择\n3.通勤时间利用\n沉淀总结1.浅尝即止是大忌：为啥这么写，这么写有啥好处，有啥坏处，多问自己几个为什么?\n2.保持好奇心：勤于在项目中发现问题，挖掘问题，多思考（深度、宽度）。\n","categories":["学习","学习方法论"],"tags":["方法论"]},{"title":"职场工作","url":"/2025/05/02/%E6%96%B9%E6%B3%95%E8%AE%BA/%E8%81%8C%E5%9C%BA%E6%B1%87%E6%8A%A5%E6%96%B9%E6%B3%95%E8%AE%BA/","content":"接受工作–只问标准*具体化\n*可衡量\n*可实现\n*相关性\n*有时限\n\n\n请示工作–必带方案*风险\n*利益\n*差异\n*影响\n汇报工作–突出结果*结论先行\n*再讲理由\n*拿出事例\n*重述结论\n分享工作–细说流程*What：产品背景\n*Who：目标人群\n*Why：预期目标\n*Where：使用场景\n*When：需求节点\n*How：如何验证\n*How much：多少资源\n复盘工作–总结SOP*回顾目标\n*评估结果，数据验证\n*分析成功、失败原因，表层&#x2F;深层原因\n*总结方法论\n","categories":["学习","职场汇报方法论"],"tags":["方法论"]}]